using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LineController : MonoBehaviour
{
    [SerializeField] private GameObject bufferPrefab;

    private LineRenderer lr;
    private Vector2[] nodes;
    private float length;
    private float[] segmentLengths;
    private float[] fractionalSegmentLengths;

    public Vector2 start;
    public Vector2 end;

    public JunctionController startJunction;
    public JunctionController endJunction;

    private void Awake() {
      lr = GetComponent<LineRenderer>();
    }

    public void SetupLine(Vector2[] nodes) {
      lr.positionCount = nodes.Length;
      this.nodes = nodes;
      start = nodes[0];
      end = nodes[^1];

      computeFractionalLengths();

      // Set placeholder junctions (buffers)
      startJunction = Instantiate(bufferPrefab, start, Quaternion.identity).GetComponent<BufferController>();
      endJunction = Instantiate(bufferPrefab, end, Quaternion.identity).GetComponent<BufferController>();
      ((BufferController) startJunction).Setup(start, this, true);
      ((BufferController) endJunction).Setup(end, this, true);
    }

    public void setStartJunction(JunctionController junction) {
        if(startJunction.autogenerated == false){ // Trying to overwrite an already set junction
            throw new Exception("Attempted to override start junction of the line "+ this);
        }
        Destroy(startJunction.gameObject);
        startJunction = junction;
    }

    public void setEndJunction(JunctionController junction) {
        if(endJunction.autogenerated == false){ // Trying to overwrite an already set junction
            throw new Exception("Attempted to override end junction of the line "+ this);
        }
        Destroy(endJunction.gameObject);
        endJunction = junction;
    }

    // Start is called before the first frame update
    public void Start()
    {
        for (int i=0; i < nodes.Length; i++) {
            lr.SetPosition(i, nodes[i]);
        }
    }

    public override string ToString() {
        return "L"+start+"->"+end;
    }

    private void computeFractionalLengths() {
        segmentLengths = new float[nodes.Length-1];
        fractionalSegmentLengths = new float[nodes.Length-1];

        for (int i=0; i < segmentLengths.Length; i++){
            Vector2 node = nodes[i];
            Vector2 nextNode = nodes[i+1];
            segmentLengths[i] = Vector2.Distance(node, nextNode);
        }
        length = segmentLengths.Sum();
        fractionalSegmentLengths = segmentLengths.Select(n => n/length).ToArray();
    }

    public Vector2 interpolate_position(float fractionalPosition) {
        if(fractionalPosition < 0 || fractionalPosition > 1){
            throw new Exception("Line cannot interpolate fractional position outwith range 0-1.");
        }

        float lengthSoFar = 0;
        for(int i=0; i<(nodes.Length-1); i++) {
            if((lengthSoFar + fractionalSegmentLengths[i]) >= fractionalPosition) {
                Vector2 node = nodes[i];
                Vector2 nextNode = nodes[i+1];
                float sectionPosition = (fractionalPosition - lengthSoFar) / fractionalSegmentLengths[i];
                return (nextNode - node)*sectionPosition;
            }
            lengthSoFar += fractionalSegmentLengths[i];
        }

        throw new Exception("Interpolation of fractional position failed.");
    }

    public List<float> intersectsCircle(float circleCentre, float circleRadius) {
        List<float> intersectionPoints; // Under normal circumstances will only contain 0, 1 or 2 elements
        float lengthSoFar = 0;

        for(int i=0; i<(nodes.Length-1); i++) {
            // See https://www.desmos.com/calculator/4rex488t3d for method
            float segmentLength = fractionalSegmentLengths[i];
            float x1 = nodes[i][0];
            float y1 = nodes[i][1];
            float x2 = nodes[i+1][0];
            float y2 = nodes[i+1][1];
            float cx = circleCentre[0];
            float cy = circleCentre[1];
            float r = circleRadius;

            float dx = x2 - x1; // The number such that x1 + dx = x2
            float dy = y2 - y1; // The number such that y1 + dy = y2

            // Coefficients of the quadratic formula to find f,
            // the fractional position on the line segment (can be
            // outside 0-1) which intersects the circle of radius of
            // the carriage length, e.g., the solution to:
            //((x1 + fdx) - cx)^2 + ((y1 + fdy) - cy)^2 = r^2

            float A = dx*dx + dy*dy;
            float B = 2*x1*dx - 2*dx*cx + 2*y1*dy - 2*dy*cy;
            float C = x1*x1 - 2*cx*x1 + cx*cx + y1**2 - 2*cy*y1 + cy*cy - r*r;

            // Implementation of quadratic formula:
            float discriminant = B**2 - 4*A*C
        }
    }
}
