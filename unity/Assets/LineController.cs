using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LineController : MonoBehaviour
{
    [SerializeField] private GameObject bufferPrefab;

    private LineRenderer lr;
    private Vector2[] nodes;
    public float length;
    private float[] segmentLengths;
    private float[] fractionalSegmentLengths;

    public Vector2 start;
    public Vector2 end;

    public JunctionController startJunction;
    public JunctionController endJunction;

    private void Awake() {
      lr = GetComponent<LineRenderer>();
    }

    public void SetupLine(Vector2[] nodes) {
      lr.positionCount = nodes.Length;
      this.nodes = nodes;
      start = nodes[0];
      end = nodes[^1];

      computeFractionalLengths();

      // Set placeholder junctions (buffers)
      startJunction = Instantiate(bufferPrefab, start, Quaternion.identity).GetComponent<BufferController>();
      endJunction = Instantiate(bufferPrefab, end, Quaternion.identity).GetComponent<BufferController>();
      ((BufferController) startJunction).Setup(start, this, true);
      ((BufferController) endJunction).Setup(end, this, true);
    }

    public void setStartJunction(JunctionController junction) {
        if(startJunction.autogenerated == false){ // Trying to overwrite an already set junction
            throw new Exception("Attempted to override start junction of the line "+ this);
        }
        Destroy(startJunction.gameObject);
        startJunction = junction;
    }

    public void setEndJunction(JunctionController junction) {
        if(endJunction.autogenerated == false){ // Trying to overwrite an already set junction
            throw new Exception("Attempted to override end junction of the line "+ this);
        }
        Destroy(endJunction.gameObject);
        endJunction = junction;
    }

    // Start is called before the first frame update
    public void Start()
    {
        for (int i=0; i < nodes.Length; i++) {
            lr.SetPosition(i, nodes[i]);
        }
    }

    public override string ToString() {
        return "L"+start+"->"+end;
    }

    private void computeFractionalLengths() {
        segmentLengths = new float[nodes.Length-1];
        fractionalSegmentLengths = new float[nodes.Length-1];

        for (int i=0; i < segmentLengths.Length; i++){
            Vector2 node = nodes[i];
            Vector2 nextNode = nodes[i+1];
            segmentLengths[i] = Vector2.Distance(node, nextNode);
        }
        length = segmentLengths.Sum();
        fractionalSegmentLengths = segmentLengths.Select(n => n/length).ToArray();
    }

    public Vector2 InterpolatePosition(float fractionalPosition) {
        if(fractionalPosition < 0 || fractionalPosition > 1){
            throw new Exception("Line cannot interpolate fractional position outwith range 0-1.");
        }

        float lengthSoFar = 0;
        for(int i=0; i<(nodes.Length-1); i++) {
            if((lengthSoFar + fractionalSegmentLengths[i]) >= fractionalPosition) {
                Vector2 node = nodes[i];
                Vector2 nextNode = nodes[i+1];
                float sectionPosition = (fractionalPosition - lengthSoFar) / fractionalSegmentLengths[i];
                return node + (nextNode - node)*sectionPosition;
            }
            lengthSoFar += fractionalSegmentLengths[i];
        }

        throw new Exception("Interpolation of fractional position failed.");
    }

    public List<float> IntersectsCircle(Vector2 circleCentre, float circleRadius) {
        List<float> intersectionPoints = new List<float>(); // Under normal circumstances will only contain 0, 1 or 2 elements
        float lengthSoFar = 0;

        for(int i=0; i<(nodes.Length-1); i++) {
            // See https://www.desmos.com/calculator/4rex488t3d for method
            float segmentLength = fractionalSegmentLengths[i];
            float x1 = nodes[i][0];
            float y1 = nodes[i][1];
            float x2 = nodes[i+1][0];
            float y2 = nodes[i+1][1];
            float cx = circleCentre[0];
            float cy = circleCentre[1];
            float r = circleRadius;

            float dx = x2 - x1; // The number such that x1 + dx = x2
            float dy = y2 - y1; // The number such that y1 + dy = y2

            // Coefficients of the quadratic formula to find f,
            // the fractional position on the line segment (can be
            // outside 0-1) which intersects the circle of radius of
            // the carriage length, e.g., the solution to:
            //((x1 + fdx) - cx)^2 + ((y1 + fdy) - cy)^2 = r^2

            float A = dx*dx + dy*dy;
            float B = 2*x1*dx - 2*dx*cx + 2*y1*dy - 2*dy*cy;
            float C = x1*x1 - 2*cx*x1 + cx*cx + y1*y1 - 2*cy*y1 + cy*cy - r*r;

            // Implementation of quadratic formula:
            float discriminant = B*B - 4*A*C;

            if (discriminant >= 0){
                float rootDiscriminant = (float) Math.Sqrt(discriminant);
                float f_plus = (-B + rootDiscriminant) / (2*A);
                float f_minus = (-B - rootDiscriminant) / (2*A);
                // Add only those points which lie on a line segment
                if (f_plus >= 0 && f_plus <= 1){
                    // Convert f position on segment to position on line
                    float linePosition = (f_plus*segmentLength) + lengthSoFar;
                    intersectionPoints.Add(linePosition);
                }
                if (f_minus >= 0 && f_minus <= 1){
                    // Convert f position on segment to position on line
                    float linePosition = (f_minus*segmentLength) + lengthSoFar;
                    intersectionPoints.Add(linePosition);
                }
            }
            lengthSoFar += segmentLength;
        }

        // Remove any points which are (very close to) identical
        intersectionPoints.Sort();
        List<float> finalIntersectionPoints = new List<float>();
        for (int i=0; i<(intersectionPoints.Count - 1); i++){
            float prev_point = intersectionPoints[i];
            float point = intersectionPoints[i+1];
            if (Math.Abs(prev_point - point) > 0.0000001){
                // Only keep instances of prev_point when they are not almost identical to point
                finalIntersectionPoints.Add(intersectionPoints[i]);
            }
        }

        return finalIntersectionPoints;
    }
}
